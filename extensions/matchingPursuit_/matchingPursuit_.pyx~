import cython
import numpy as np
cimport numpy as np

#C external functions
cdef extern from "math.h":
    double exp(double)
    double sqrt(double)
    double cos(double)
    double sin(double)
    double atan2(double, double)

cdef double pi = 3.1415926535897931

#Gaussian windows

@cython.profile(False)
cdef inline double gauss(int i, int N):
    return exp(-( (i - N/2. )**2) / (2. * ( (0.125 * N)**2)))

@cython.profile(False)
cdef inline double realSinusoid(int i, float omega, float phi):
    return cos(2 * pi * omega * i + phi)

'''
#MPTK's
cdef double gauss(int i, int N):
    return exp( -(i -(N/2. - 1) / 2.) * (i -(N/2. - 1) / 2.) * (1./(2 * 0.02 * (N/2. +1)**2))) 

cpdef double gauss_(int i, int N):
    return exp( -((i -(N/2. - 1)) / 2.) * ((i -(N/2. - 1)) / 2.) * (1./(2 * 0.02 * (N/2. +1)**2))) 

#Gabor's
cdef double gauss(int i, int N):
    cdef double alpha = 0.005
    return exp( -(alpha**2) * (i - N/2.)**2)
'''

#two point norm to measure magnitude of coefficient
cdef double norm(double c, double s):
    return sqrt(c**2 + s**2)

#probably a more efficient argmax somewhere...
cdef int argmax(np.ndarray[np.float_t, ndim=1, mode="c"] ar, int length):
    cdef double m = 0.
    cdef int i
    for k in range(length):
        if ar[k] > m:
            m = ar[k]
            i = k
    return i  

@cython.nonecheck(False)
@cython.boundscheck(False)
def matchingPursuit_(np.ndarray[np.float_t, ndim=1, mode="c"] signal, dictionary, np.ndarray[np.int32_t, ndim=1, mode="c"] N, int cmax, double pmdc, np.ndarray[np.float_t, ndim=1, mode="c"] insignal):
    
    #initialization
    cdef double delta_measure = np.inf, measure, m1, m2, mc0, mc1, mag, c_omega, c_mag, c_phase, cn1, cn2, a_point, delta_thresh
    
    cdef np.ndarray[np.int32_t, ndim=1, mode="c"] locs = np.array(dictionary['onset'])
    cdef np.ndarray[np.int32_t, ndim=1, mode="c"] scales = np.array(dictionary['scale'])
    cdef np.ndarray[np.float_t, ndim=1, mode="c"] omegas = np.array(dictionary['omega'])
    
    cdef int c_cnt = 0, L = len(signal), L_N = len(N), L_D = len(locs), max_scale = max(dictionary['scale']), cnt, n, cm, start, end, indx, pindx, k, c_scale, c_loc, cs

    cdef np.ndarray[np.float_t, ndim=1, mode="c"] atom1 = np.zeros(max_scale, dtype=np.float)
    cdef np.ndarray[np.float_t, ndim=1, mode="c"] atom2 = np.zeros(max_scale, dtype=np.float)

    cdef np.ndarray[np.float_t, ndim=1, mode="c"] out = np.zeros(L)
    cdef np.ndarray[np.int32_t, ndim=1, mode="c"] max_ind = np.zeros(L_N, dtype=np.int32)
    cdef np.ndarray[np.int32_t, ndim=1, mode="c"] up_ind = np.arange(L_N, dtype=np.int32)
    cdef np.ndarray[np.float_t, ndim=1, mode="c"] max_mag = np.zeros(L_N, dtype=np.float)
    cdef np.ndarray[np.float_t, ndim=1, mode="c"] max_phase = np.zeros(L_N, dtype=np.float)

    for cm in range(L):
            m1 += signal[cm]**2
            m2 += insignal[cm]**2
    
    cdef double last_measure = m1/m2
    
    #to store the molecule contents
    cdef np.ndarray[np.int32_t, ndim=1, mode="c"] M_scales = np.zeros(cmax, dtype=np.int32)
    cdef np.ndarray[np.int32_t, ndim=1, mode="c"] M_locs = np.zeros(cmax, dtype=np.int32)
    cdef np.ndarray[np.float_t, ndim=1, mode="c"] M_omegas = np.zeros(cmax, dtype=np.float)    
    cdef np.ndarray[np.float_t, ndim=1, mode="c"] M_mags = np.zeros(cmax, dtype=np.float)
    cdef np.ndarray[np.float_t, ndim=1, mode="c"] M_phases = np.zeros(cmax, dtype=np.float)

    while (c_cnt < cmax) and (delta_measure > delta_thresh):

        print(c_cnt)
       
        for cnt in up_ind:
            start = N[cnt]

            for k in range(L_D):
                if locs[k]  == start:
                    c_scale = scales[k]
                    c_omega = omegas[k]
                
                    cn1 = 0.
                    cn2 = 0.
                
                    #build atoms and calculate norms
                    for cs in range(c_scale):

                        #a1 = gauss(cs, c_scale) * cos(2 * pi * c_omega * cs)
                        a1 = gauss(cs, c_scale) * realSinusoid(cs, c_omega, 0.)
                        cn1 += a1*a1
                        #a2 = gauss(cs, c_scale) * -sin(2 * pi * c_omega * cs)
                        a1 = gauss(cs, c_scale) * realSinusoid(cs, c_omega, pi/2)
                        cn2 += a2*a2
                        atom1[cs] = a1
                        atom2[cs] = a2
                
                    a1 = sqrt(cn1)
                    a2 = sqrt(cn2)
                    for cs in range(c_scale):
                        atom1[cs] /= a1
                        atom2[cs] /= a2

                    cn1 = 0.
                    cn2 = 0.
                
                    #inner product, make function?
                    for cs in range(c_scale):
                        cn1 += atom1[cs] * signal[start+cs]
                        cn2 += atom2[cs] * signal[start+cs]
                        
                    mag = norm(cn1, cn2)

                    #store max values (coefficient and corresponding index) for each time interval, i.e. best atom starting at a given point                                          
                    if mag > max_mag[cnt]:
                        max_mag[cnt] = mag
                        max_phase[cnt] = atan2(cn2, cn1) 
                        max_ind[cnt] = k

        #get and remove maximally correlated atom
        #indx = max_mag.argmax()
        indx = argmax(max_mag, L_N)
        pindx = max_ind[indx]
        
        c_scale = scales[pindx]
        c_loc = locs[pindx] 
        c_omega = omegas[pindx]
        c_phase = max_phase[indx]
        c_mag = max_mag[indx]

        cn1 = 0.

        #build atom sample by sample
        for cs in range(c_scale):

            #a1 = gauss(cs, c_scale) * cos(2 * pi * c_omega * cs + c_phase)
            a1 = gauss(cs, c_scale) * realSinusoid(cs, c_omega, c_phase)
            cn1 += a1*a1

            atom1[cs] = a1
                
        a1 = sqrt(cn1)
        
        for cs in range(c_scale):
            atom1[cs] /= a1

        #subtract from signal and add to synthesis sample by sample
        for cs in range(c_scale):
            signal[c_loc+cs] -= atom1[cs] * c_mag
            out[c_loc+cs] += atom1[cs] * c_mag

        #add to molecule synth Book
        M_scales[c_cnt] = c_scale
        M_locs[c_cnt] = c_loc
        M_omegas[c_cnt] = c_omega
        M_mags[c_cnt] =  c_mag
        M_phases[c_cnt] = c_phase
                
        #Measure the change    
        m1 = 0. 

        for cm in range(L):
            m1 += signal[cm]**2
        
        measure = m1/m2
        delta_measure = last_measure - measure
        last_measure = measure
        
        #something better to avoid if check...
        if (c_cnt == 0):
            delta_thresh = (delta_measure * pmdc)

        print(measure)
        print(delta_measure)
	
        #find which indices to update
        UL = []
        for cs in range(L_N):
            n = N[cs]
            if (n >= c_loc - max_scale) and (n < c_loc + max_scale):
                UL.append(cs)
                max_mag[cs] = 0.
                 
        up_ind = np.array(UL)

        c_cnt += 1

    M = {'scale': M_scales[0:c_cnt], 'onset': M_locs[0:c_cnt], 'omega': M_omegas[0:c_cnt], 'mag': M_mags[0:c_cnt], 'phase' : M_phases[0:c_cnt]}
    
    return out, signal, M
